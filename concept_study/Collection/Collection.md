__① collection Framework 개념__
- 요소(element)라고 불리는 객체들을 담는 저장소(그릇)이다. (참고.c/c++의 StL와 같은 느낌이다.)
- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스(객체)의 집합의 의미이다.

__② 특징__
- 요소의 개수의 따라 크기가 자동 조절된다.
- 삽입, 삭제에 따른 요소의 위치가 자동 이동된다.

__③ 분류__
- collection Framework는 크게 "Collection" , "Map"으로 나누어 진다. -> 이둘은 인터페이스이다.
- collection은 List와 Set, Queue으로 나누어 지고 이둘도 인터페이스이다.

![222](https://user-images.githubusercontent.com/96917871/150382274-f3a5013c-dbe1-42cf-8c47-cbd99b7e7caf.PNG)

(2) Vector
- ArrayList에 동기화가 보장되도록 최적화한 클래스.
- 모든 메소드가 동기화 되어있어서 잘 사용하지 않음.

(3) LinkedList
- 노드, 링크 로 구성된다.
- 양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번할 경우에 빠른 성능을 보장함. 삽입, 삭제 : O(1) / 검색 : O(n)
- 배열과의 비교 : 배열은 검색하는데 O(1)이지만, 삽입, 삭제할때는 배열의 복사, 이동 과정에 많이 소요됨. 그래서 탐색이 많이 필요한 상황에서는 배열을 사용하고, 삽입/삭제가 필요한 상황에서는 LinkedList를 사용하는 것이 효율적이다.
- 이름처럼 데이터를 담고있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전노드와의 연결을 담당한다.
- 스택, 큐, 양방향큐(덱) 등을 만들기 위한 용도로 사용.

2) Set  [순서X, 중복X]
- 수학의 집합 같은 개념의 콜렉션.
- 순서가 상관없고, 요소의 중복을 허용하지 않는다.

(1) HashSet
- Hashing을 이용해서 구현한 컬렉션.
- 데이터를 중복저장할 수 없고, 순서를 보장하지 않음.
- equals()나 hashCode()를 오버라이딩해서, 인스턴스가 달라도 동일 객체를 구분해 중복저장을 막을 수 있다.
-> HashSet에 객체를 저장하기 전에 hashCode()를 호출해서 해시코드를 얻어내는데, 이미 저장되어있는 객체들의 해시코드와 비교해서 만약 동일한 해시코드가 있다면
다시 equals()로 두 객체를 비교해 true가 나오면 동일객체로 판단하여 중복저장을 하지 않는 방식임! ^_^


(2) LinkedHashSet
- HashSet클래스를 상속받은 LinkedList다.
- 데이터가 삽입된 순서대로 데이터를 관리한다.

(3) TreeSet
- 정렬O
- 정렬된 순서대로 보관하며 정렬방법을 지정할 수 있음.
- 이진탐색트리(Red-Black-Tree) 형태로 데이터를 저장함.
- 데이터를 추가,삭제에는 시간이 더 걸리지만, 검색과 정렬이 더 뛰어나다.
- 기본적으로는 오름차순으로 데이터를 저장한다.


